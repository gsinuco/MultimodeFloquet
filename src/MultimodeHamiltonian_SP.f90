SUBROUTINE MULTIMODEFLOQUETMATRIX_SP(ATOM_,NM,NF,MODES_NUM,FIELDS,VALUES_,ROW_INDEX_,COLUMN_,INFO)
  
  USE TYPES !(modes.f90)
  USE MERGINGARRAYS !(utils.f90)
  
  IMPLICIT NONE
  INTEGER                  ,INTENT(IN)    :: NM,NF
  TYPE(MODE), DIMENSION(NF),INTENT(INOUT) :: FIELDs
  TYPE(ATOM),               INTENT(IN)    :: ATOM_
  INTEGER, DIMENSION(NM),   INTENT(IN)    :: MODES_NUM
  INTEGER,                  INTENT(INOUT) :: INFO
  COMPLEX*16, DIMENSION(:), ALLOCATABLE,INTENT(OUT) :: VALUES_
  INTEGER,    DIMENSION(:), ALLOCATABLE,INTENT(OUT) :: COLUMN_
  INTEGER,    DIMENSION(:), ALLOCATABLE,INTENT(OUT) :: ROW_INDEX_
  
  
  COMPLEX*16, DIMENSION(:,:), ALLOCATABLE :: V_AUX
  COMPLEX*16, DIMENSION(:),   ALLOCATABLE :: VALUES,ARRAY_AUX,VALUES_OLD,VALUES_OLD_
  INTEGER,    DIMENSION(:),   ALLOCATABLE ::ROW,COLUMN,ARRAYI_AUX,ROW_OLD,COLUMN_OLD,ROW_INDEX,INDEX_ORDERROW
  INTEGER,    DIMENSION(NF)               :: N_FLOQUET
  
  INTEGER :: D_MULTIFLOQUET
  INTEGER m,r,c,index,D,counter, N_MODES,values_dim,D_bare,t
  CHARACTER*1 UPLO
  
  !PARAMETERS REQUIRED TO TEST THE DIAGONALIZATION ROUTINE
!!$  COMPLEX*16,      DIMENSION(:,:),ALLOCATABLE :: U_F
!!$  DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE :: E_FLOQUET
!!$  DOUBLE PRECISION :: E_L,E_R

  N_MODES = NF
  D_bare = ATOM_%D_BARE
  info   = 0

  ALLOCATE(VALUES(D_bare*D_bare))
  ALLOCATE(ROW(D_bare*D_bare))
  ALLOCATE(COLUMN(D_bare*D_bare))

  !DEFINITION OF THE MATRICES: BY HAND  
  DO r=1,NF
     N_FLOQUET(r) = FIELDS(r)%N_FLOQUET
  END DO
    
  ! COORDINATE PACKING OF EACH FIELD
  
  D_MULTIFLOQUET = SIZE(FIELDS(1)%V,1)
  DO m=1,NF
     CALL COORDINATEPACKING(D_bare,FIELDS(m)%V,VALUES,ROW,COLUMN,index,INFO)
     ALLOCATE(FIELDS(m)%VALUES(index))
     IF(m.eq.1) FIELDS(m)%VALUES = VALUES(1:index)
     IF(m.ne.1) FIELDS(m)%VALUES = VALUES(1:index)/2.0
!     write(*,*) real(fields(m)%values)
!     write(*,*) fields(m)%omega
     ALLOCATE(FIELDS(m)%ROW(index))
     FIELDS(m)%ROW = ROW(1:index)
!     WRITE(*,*) FIELDS(m)%ROW
     ALLOCATE(FIELDS(m)%COLUMN(index))
     FIELDS(m)%COLUMN = COLUMN(1:index)
!     WRITE(*,*) FIELDS(m)%COLUMN
     D_MULTIFLOQUET = D_MULTIFLOQUET*(2*N_FLOQUET(m)+1)
!     write(*,*) d_multifloquet
  END DO
!  WRITE(*,*)

  ! WE HAVE TO REDEFINE VALUES,ROW,COLUMN FOR m > 2 as follows:
  D = D_bare
  index = 1
  DO m=3,NF
     DEALLOCATE(VALUES)
     DEALLOCATE(ROW)
     DEALLOCATE(COLUMN)
     ALLOCATE(VALUES(SIZE(FIELDS(m)%VALUES,1)))
     ALLOCATE(ROW(SIZE(FIELDS(m)%VALUES,1)))
     ALLOCATE(COLUMN(SIZE(FIELDS(m)%VALUES,1)))
     ALLOCATE(ARRAYI_AUX(SIZE(FIELDS(m)%VALUES,1)))
     VALUES = FIELDS(m)%VALUES
     ROW    = FIELDS(m)%ROW
     COLUMN = FIELDS(m)%COLUMN
     DO r=2,2*N_FLOQUET(m-1)+1
        CALL APPENDARRAYS(VALUES,FIELDS(m)%VALUES,INFO)
        ARRAYI_AUX = FIELDS(m)%ROW + (r-1)*D
        CALL APPENDARRAYSI(ROW,ARRAYI_AUX,INFO)
        ARRAYI_AUX =  FIELDS(m)%COLUMN + (r-1)*D
        CALL APPENDARRAYSI(COLUMN,ARRAYI_AUX,INFO)
     END DO
     DEALLOCATE(FIELDS(m)%VALUES)
     DEALLOCATE(FIELDS(m)%ROW)
     DEALLOCATE(FIELDS(m)%COLUMN)
     DEALLOCATE(ARRAYI_AUX)
     ALLOCATE(FIELDS(m)%VALUES(SIZE(VALUES,1)))
     ALLOCATE(FIELDS(m)%ROW(SIZE(VALUES,1)))
     ALLOCATE(FIELDS(m)%COLUMN(SIZE(VALUES,1)))
     FIELDS(m)%VALUES = VALUES
     FIELDS(m)%ROW    = ROW
     FIELDS(m)%COLUMN = COLUMN
!     write(*,*) D
!     write(*,*) abs(values)
!     write(*,*) row
!     write(*,*) column
     D = D*(2*N_FLOQUET(m-1)+1)     
  END DO
  DEALLOCATE(VALUES)
  DEALLOCATE(ROW)
  DEALLOCATE(COLUMN)
  
  
  ! BUILDING THE COORDINATE PACKING OF THE MULTIMODE HAMILTONIAN MATRIX
  D = D_bare
  values_dim = 0  
  ALLOCATE(VALUES_OLD(SIZE(FIELDS(1)%VALUES,1)))
  ALLOCATE(ROW_OLD(SIZE(FIELDS(1)%VALUES,1)))
  ALLOCATE(COLUMN_OLD(SIZE(FIELDS(1)%VALUES,1)))
  ALLOCATE(VALUES(SIZE(FIELDS(1)%VALUES)))
  ALLOCATE(ROW(SIZE(FIELDS(1)%VALUES)))
  ALLOCATE(COLUMN(SIZE(FIELDS(1)%VALUES)))
  VALUES = FIELDS(1)%VALUES
  ROW    = FIELDS(1)%ROW
  COLUMN = FIELDS(1)%COLUMN
  VALUES_OLD = FIELDS(1)%VALUES
  ROW_OLD    = FIELDS(1)%ROW
  COLUMN_OLD = FIELDS(1)%COLUMN  
!  write(*,*)values_old
  DO m=2,NF
     ALLOCATE(ARRAYI_AUX(SIZE(FIELDS(m)%ROW,1)))
     ALLOCATE(VALUES_OLD_(SIZE(VALUES_OLD,1)))
     VALUES_OLD_ = VALUES_OLD
     DO r=1,2*N_FLOQUET(m) + 1
        DO c = 1,2*N_FLOQUET(m) + 1
           index = c-r
           
           IF(index.EQ.0) THEN
              
              DO t=1,SIZE(VALUES_OLD,1)
                 IF(COLUMN_OLD(t).EQ.ROW_OLD(t)) VALUES_OLD_(t) = VALUES_OLD(t) + 1.0*(-N_FLOQUET(m)+c-1)*FIELDS(m)%OMEGA
              END DO
              IF(c.NE.1) THEN
                 CALL APPENDARRAYS(VALUES,VALUES_OLD_,INFO)
                 CALL APPENDARRAYSI(COLUMN,COLUMN_OLD+(c-1)*D,INFO)
                 CALL APPENDARRAYSI(ROW,ROW_OLD+(c-1)*D,INFO)
              ELSE
                 VALUES = VALUES_OLD_
              END IF
           ELSE IF(ABS(index).EQ.1) THEN            
              CALL APPENDARRAYS(VALUES,FIELDS(m)%VALUES,INFO)
              ARRAYI_AUX =  FIELDS(m)%COLUMN + (c-1)*D
              CALL APPENDARRAYSI(COLUMN,ARRAYI_AUX,INFO)
              
              ARRAYI_AUX =  FIELDS(m)%ROW + (r-1)*D
              CALL APPENDARRAYSI(ROW,ARRAYI_AUX,INFO)
           END IF
        END DO
     END DO
     
     D = D*(2*N_FLOQUET(m)+1)
     DEALLOCATE(VALUES_OLD_)
     DEALLOCATE(VALUES_OLD)
     DEALLOCATE(ROW_OLD)
     DEALLOCATE(COLUMN_OLD)
     DEALLOCATE(ARRAYI_AUX)
     
     ALLOCATE(VALUES_OLD(SIZE(VALUES,1)))
     ALLOCATE(ROW_OLD(SIZE(VALUES,1)))
     ALLOCATE(COLUMN_OLD(SIZE(VALUES,1)))
     VALUES_OLD = VALUES
     ROW_OLD    = ROW
     COLUMN_OLD = COLUMN
  END DO
  
  DEALLOCATE(VALUES_OLD)
  DEALLOCATE(ROW_OLD)
  DEALLOCATE(COLUMN_OLD)
  
  ! BUILDING THE VARIATION CRS PACKING OF THE MULTIMODE HAMILTONIAN MATRIX, USING THE COORDINATE PACKING

  !  DO r=1,size(VALUES,1)
  !     WRITE(*,*) ROW(r),COLUMN(r),REAL(VALUES(r))
  !  END DO
  !    WRITE(*,*) SIZE(VALUES,1)
  !    WRITE(*,*) REAL(VALUES)
  !    WRITE(*,*) ROW
  !    WRITE(*,*) COLUMN
  !WRITE(*,*) 
  ALLOCATE(INDEX_ORDERROW(SIZE(ROW,1)))
  CALL QUICK_SORT_INTEGERS(ROW,INDEX_ORDERROW,SIZE(ROW,1))
  ROW    = ROW(INDEX_ORDERROW)
  COLUMN = COLUMN(INDEX_ORDERROW)
  VALUES = VALUES(INDEX_ORDERROW)
  
  ! write(*,*) row
  ! WRITE(*,*)
  ! write(*,*) column
  ! WRITE(*,*)
  ! WRITE(*,*) D_MULTIFLOQUET
  
  
  ALLOCATE(ROW_INDEX(D_MULTIFLOQUET+1))
  ROW_INDEX = -1
  ROW_INDEX(D_MULTIFLOQUET+1) = SIZE(VALUES,1)+1
  
  counter = 1
  
  D = 1
  ROW_INDEX(1)=1
  DO r = 2,SIZE(ROW,1)
     IF(ROW(r).EQ.ROW(r-1)) THEN
        counter = counter +1        
     ELSE
        D = D + counter
        ROW_INDEX(ROW(r)) =D
        counter = 1
     END IF
  END DO
  !  WRITE(*,*) D_MULTIFLOQUET,nf
!!$  E_L = -6.0
!!$  E_R =  6.0
!!$  ALLOCATE(E_FLOQUET(D_MULTIFLOQUET))
!!$  ALLOCATE(U_F(D_MULTIFLOQUET,D_MULTIFLOQUET))
!!$  CALL MKLSPARSE_FULLEIGENVALUES(D_MULTIFLOQUET,SIZE(VALUES,1),VALUES,ROW_INDEX,COLUMN,E_L,E_R,E_FLOQUET,U_F,INFO)
!!$  write(*,*) E_FLOQUET
  ALLOCATE(VALUES_(SIZE(VALUES,1)))
  ALLOCATE(ROW_INDEX_(SIZE(ROW_INDEX,1)))
  ALLOCATE(COLUMN_(SIZE(COLUMN,1)))
  
  VALUES_    = VALUES
  ROW_INDEX_ = ROW_INDEX
  COLUMN_    = COLUMN
  
  DEALLOCATE(VALUES)
  DEALLOCATE(ROW)
  DEALLOCATE(COLUMN)
  DEALLOCATE(ROW_INDEX)

END SUBROUTINE MULTIMODEFLOQUETMATRIX_SP ! _SP  sparse packing

